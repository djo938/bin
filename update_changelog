#!/usr/bin/env bash

IFS_BU=$IFS
source install_function
source utils_function

function vercomp {
    if [[ $1 == $2 ]]; then
        return 0
    fi

    local i
    IFS=. ver1=($1)
    IFS=. ver2=($2)
    IFS=$IFS_BU

    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done

    for ((i=0; i<${#ver1[@]}; i++)); do
        # fill empty fields in ver2 with zeros
        if [[ -z ${ver2[i]} ]]; then
            ver2[i]=0
        fi

        if ((10#${ver1[i]} > 10#${ver2[i]})); then
            return 1
        fi

        if ((10#${ver1[i]} < 10#${ver2[i]})); then
            return 2
        fi
    done
    return 0
}

file_exists "setup.py"
directory_exists "debian"
# TODO manage empty or no debian/changelog file
file_exists "debian/changelog"
directory_exists ".git"
install_with_apt "git"

IFS=$'\n' tag_list=($(git tag -l))
IFS=$IFS_BU

if [[ "${#tag_list[@]}" -eq 0 ]]; then
    quit "no tag available"
fi

package_name=$(python setup.py --name)
author_name=$(python setup.py --contact)
author_mail=$(python setup.py --contact-email)

# extract and parse the first line in the changelog
changelog_first_line=$(head -n 1 "./debian/changelog")
stop_if_failure "fail to read changelog file"

if [[ -z "$changelog_first_line" ]]; then
    quit "empty changelog first line"
fi

if [[ !( $changelog_first_line =~ ^[a-z]+\ \([0-9]+\.[0-9]+\.[0-9]+-[0-9]+\)(\ [a-z]+)+\;(\ [a-z]+=[a-z]+)*$ ) ]]; then
    quit "invalid changelog first line"
fi

IFS=$' ' changelog_first_line=($changelog_first_line)
IFS=$IFS_BU

changelog_project_name=${changelog_first_line[0]}
to_parse=${changelog_first_line[1]}
to_parse=${to_parse:1:-1}  # remove the parentheses

IFS=- read changelog_project_version changelog_packaging_version the_rest <<< "$to_parse"
IFS=$IFS_BU

if [[ "$package_name" != "$changelog_project_name" ]]; then
    quit "changelog project name mismatches"
fi

# only keep 
filtered_tag_list=()
for tag in ${tag_list[@]}; do
    if [[ !( $tag =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ) ]]; then
        continue
    fi

    vercomp $tag $changelog_project_version
    if [[ $? -eq 2 ]]; then
        continue
    fi

    IFS=$'\n' branches=($(git branch --contains $tag))
    IFS=$IFS_BU

    if [[ "${#branches[@]}" -eq 0 ]]; then
        quit "ERROR: tag $tag isn't associate to a branch"
    fi
    result=$(containsElement "master" $branches)
    if [[ "$result" -eq 1 ]]; then
        echo "WARNING: tag $tag is not on the master branch"
        continue
    fi

    filtered_tag_list=(${filtered_tag_list[@]} $tag)
done

# TODO be sure there is no overlap betweens the tags

result=$(git tag -l "$changelog_project_version")
if [[ -z "$result" ]]; then
    echo "WARNING no git tag corresponding to the last version found in the changelog: $changelog_project_version"
    starting_position=0
else
    starting_position=1
fi
# sort the tags
sorted_tag_list=()
for tag in ${filtered_tag_list[@]}; do
    position=$starting_position
    for other_tag in ${filtered_tag_list[@]}; do
        if [[ $tag == $other_tag ]]; then
            continue
        fi

        vercomp $tag $other_tag
        if [[ $? -eq 2 ]]; then
            position=$((position+1))
        fi
    done
    sorted_tag_list[$position]=$tag
done

if [[ "$starting_position" -eq 1 ]]; then
    sorted_tag_list+=($changelog_project_version)
fi

# need at least two version to do something
if [[ "${#sorted_tag_list[@]}" -lt 2 ]]; then
    quit "not enough version tag found to update changelog"
fi

# TODO
#   make the same but use the tools dch
#   install_with_apt "devscripts"

# build changelog entry for each missing tag
lines_to_add=()
for (( j=$(( ${#sorted_tag_list[@]} -1 )); j>0; j-- )); do
    tag=${sorted_tag_list[$(($j-1))]}
    previous_tag=${sorted_tag_list[$j]}
    IFS=$'\n' commit_messages=($(git log --pretty=format:%s "$previous_tag..$tag"))
    IFS=$IFS_BU

    if [[ "${#commit_messages[@]}" -eq 0 ]]; then
        echo "WARNING no commit between tag $previous_tag and $tag, skip it"
        previous_tag=$tag
        continue
    fi

    line="$changelog_project_name ($tag-1) unstable; urgency=low"
    lines_to_add+=("$line")
    lines_to_add+=("")

    too_big=0
    # for msg in ${commit_messages[@]}; do
    for (( i=0; i<=$(( ${#commit_messages[@]} -1 )); i++ )); do
        msg=${commit_messages[$i]}
        if [[ "${#msg}" -gt 76 ]]; then
            too_big=1
        fi

        line="  * $msg"        
        lines_to_add+=("$line")
    done

    if [[ "$too_big" -eq 1 ]]; then
        echo "WARNING one or several commit message are bigger than 76 characters on tag $tag"
    fi

    tag_date=$(git show -s --format=%cD $tag)
    line=" -- $author_name <$author_mail>  $tag_date"
    lines_to_add+=("")   
    lines_to_add+=("$line")
    lines_to_add+=("")

    previous_tag=$tag
done

# get previous changelog content
IFS=$'\n'
while read line; do
    lines_to_add+=("$line")
done < "debian/changelog"
IFS=$IFS_BU

# remove every empty line at the end
last_index_to_write=$(( ${#lines_to_add[@]} -1 ))
for (( i=$last_index_to_write; i>=0; i-- )); do
    if [[ -n "${lines_to_add[$i]}" ]]; then
        break
    fi
    last_index_to_write=$(( $last_index_to_write -1 ))
done

# flush the changelog file
> "debian/changelog"

# full in the file
for (( i=0; i<=$last_index_to_write; i++ )); do
    echo "${lines_to_add[$i]}" >> "debian/changelog"
done
