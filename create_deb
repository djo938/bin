#!/usr/bin/env bash

source ~/.bashrc  # update PATH to have access to pclear
source install_function
source utils_function

python_cmd=python2.7

# redifine quit to clean the building environment
function quit {
    # clean the popd/pushd stack and go back to entry directory
    cd "$(dirs -l -0)" && dirs -c

    # remove temp directory if any
    remove_directory "./dist/temp"

    # print message then quit
    msg "$1"
    exit
}


###############################################
# CHECK & PREPARE CONTEXT                     #
###############################################

if [ -z "lsb_release -f | grep 16.04" ]; then
    quit "this script was designed and only tested with Ubuntu 16.04 Xenial"
fi

# is it a python project directory ?
file_exists "setup.py"

# check debian directory
if [[ !( -d "debian" ) ]]; then
    if [[ -e "debian" ]]; then
        quit "debian file is not a directory"
    fi

    msg "no debian directory found, try to create it"

    install_with_pip "stdeb"
    $python_cmd setup.py --quiet --command-packages=stdeb.command debianize
    stop_if_failure "failed to create the debian directory"
fi

# check git directory
if [[ -d ".git"  ]]; then
    install_with_apt "git"

    current_tag=$(git describe --tags)
    existing_tags=$(git tag -l)

    # always supposed to create package on release tag
    tag_error=0
    containsElement $current_tag $existing_tags
    if [ $? -eq 1 ]; then
        msg "WARNING: not on a git tag"
        tag_error=1
    fi

    if [[ !( $current_tag =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ) ]]; then
        msg "WARNING: not a git production tag"
        tag_error=1
    fi

    # not supposed to create package outside of the master branch
    if [ $tag_error -eq 0 ]; then
        current_branch=$(git rev-parse --abbrev-ref HEAD)

        if [ $current_branch != "master" ]; then
            msg "WARNING: not on the master branch"
        fi
    fi
fi

###############################################
# INSTALL/CHECK SOFTWARE NEEDED FOR PACKAGING #
###############################################

# need debhelper to process the package creation
install_with_apt "debhelper"

# needed for dpkg-buildpackage
install_with_apt "dpkg-dev"
install_with_apt "python-all"

# tools to check the package quality
install_with_apt "lintian"

###############################################
# CREATE SOURCE AND BINARY PACKAGE            #
###############################################

# clean/prepare the package directory
remove_directory ./dist
mkdir dist
mkdir dist/temp
rsync -a --exclude="dist" ./* ./dist/temp/

# generate a tarball
pushd dist > /dev/null
pushd temp > /dev/null

# remove every useless directory for the installation
pclear
remove_directory ./.tox
remove_directory ./tests
remove_directory ./.eggs
find . -name "test" -type d -prune -exec rm -r "{}" \;
rm -f ./*.ini
rm -f ./*.sh
rm -f ./LICENSE
rm -f ./MANIFEST

# rename README.md to README if exist
#   it removes a warning of sdist
if [[ !( -e "README" ) ]] && [[ -e "README.md" ]]; then
    mv README.md README
fi 

msg "creating tarball"
$python_cmd setup.py --quiet sdist --formats=gztar
stop_if_failure "fail to create tarball"

# small hack to remove some warnings
# buildpackage expects to have two more files in the code directory:
#   * setup.cfg
#   * PKG-INFO
#
# but these files are created at the same time of the tarball
# so just extract them from the tarball if they don't exist

package_name=$(python setup.py --name)
package_version=$(python setup.py --version)
project_full_name="$package_name-$package_version"
tarball_filename="$project_full_name.tar.gz"
tarball_filepath="./temp/dist/$tarball_filename"

# back to ./dist
popd > /dev/null

# extract setup.cfg from tarball
setupcfg_path="$project_full_name/setup.cfg"
exist=$(tar -tf $tarball_filepath $setupcfg_path 2> /dev/null)

if [[ -n "$exist" ]]; then
    if [[ !( -e "./temp/setup.cfg" ) ]]; then
        
        tar -xzf $tarball_filepath $setupcfg_path
        mv $setupcfg_path ./temp/
    fi
fi

# extract PKG-INFO from tarball
pkginfo_path="$project_full_name/PKG-INFO"
exist=$(tar -tf $tarball_filepath $pkginfo_path 2> /dev/null)

if [[ -n "$exist" ]]; then
    if [[ !( -e "./temp/PKG-INFO" ) ]]; then
        
        tar -xzf $tarball_filepath $pkginfo_path
        mv $pkginfo_path ./temp/
    fi
fi

remove_directory "$project_full_name"

# buildpackage expect a file name like NAME_VER.orig.tar.gz
# and sdist produce a file name like NAME-VER.tar.gz
# buildpackage expect a NAME in lower case
mv "$tarball_filepath" "./${package_name,,}_${package_version}.orig.tar.gz"

# start packaging
pushd temp > /dev/null

# avoid an incomprehensible error with dpkg-buildpackage
changelog_first_line=$(head -n 1 "./debian/changelog")
stop_if_failure "fail to read changelog file"

if [[ $changelog_first_line != *"($package_version-"* ]]; then
    quit "the last changelog entry mismatch with the current package version"
fi

msg "building binary package"
dpkg-buildpackage -F
binary_build_status=$?
popd > /dev/null

var="python-${package_name}_${package_version}-"?_all.deb
echo $var
pwd

result=$(ls "python-${package_name}_${package_version}-"1_all.deb)
if [[ -n "$result" ]]; then
    mkdir binaries
    mv "${package_name}_${package_version}-"?.debian.tar.xz ./binaries/
    mv "${package_name}_${package_version}-"?.dsc ./binaries/
    mv "${package_name}_${package_version}-"?_*.changes ./binaries/
    mv "python-${package_name}_${package_version}-"?_all.deb ./binaries/

    pushd binaries
    lintian -i -I *.deb
    popd
    
else
    quit "error/warning on binary packaging, no file found."
fi

remove_directory "./temp/${package_name}.egg-info"

pushd temp > /dev/null
msg "building source package"
dpkg-buildpackage -S
source_build_status=$?
popd > /dev/null

result=$(ls "${package_name}_${package_version}-"1_source.changes)
if [[ -n $result ]]; then
    mkdir sources
    mv "${package_name}_${package_version}-"?.debian.tar.xz ./sources/
    mv "${package_name}_${package_version}-"?.dsc ./sources/
    mv "${package_name}_${package_version}-"?_source.changes ./sources/
else
    quit "error/warning on source packaging, no file found"
fi

error_msg=
if [[ $binary_build_status -ne 0 ]]; then
    error_msg="ERROR occurs on the binary package build, review the output"
fi

if [[ $source_build_status -ne 0 ]]; then
    if [[ -n "$error_msg" ]]; then
        error_msg="$error_msg\n"
    fi
    
    error_msg="${error_msg}ERROR occurs on the source package build, review the output"
fi

if [[ -z "$error_msg" ]]; then
    error_msg="success"
fi

quit "$error_msg"
